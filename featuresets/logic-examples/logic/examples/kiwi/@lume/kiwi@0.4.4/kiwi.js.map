{"mappings":"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","names":["createMap","IndexedMap","_IndexedMap","index","key","i","factory","pair","Pair","value","last","copy","_Pair","first","second","Variable","name","context","value","Expression","coefficient","VarId","Expression","_Expression","parsed","parseArgs","result","i","n","pair","value","coefficient","args","constant","factory","terms","createMap","item","Variable","terms2","j","k","termPair","value2","Strength","_Strength","a","b","c","w","result","value","Operator","Constraint","expression","operator","rhs","strength","Strength","Expression","CnId","Solver","lhs","operator","rhs","strength","Strength","cn","Constraint","constraint","data","row","tag","subject","SymbolType","nearZero","cnPair","marker","rowPair","leaving","first","variable","expr","Expression","Operator","info","editPair","value","rows","delta","other","i","n","coeff","vars","pair","factory","Row","terms","termPair","symbol","basicPair","objective","INVALID_SYMBOL","slack","error","errplus","errminus","dummy","cells","type","art","success","basicRow","entering","iterations","infeasible","ratio","c","r","found","temp","temp_ratio","dmax","r1","r2","invalid","second","third","Symbol","createCnMap","createRowMap","createVarMap","createEditMap","eps","createMap","id","_Row","constant","theCopy","coefficient"],"sources":["../esm/npm/@lume/kiwi@0.4.4/node_modules/@lume/kiwi/dist/maptype.js","../esm/npm/@lume/kiwi@0.4.4/node_modules/@lume/kiwi/dist/variable.js","../esm/npm/@lume/kiwi@0.4.4/node_modules/@lume/kiwi/dist/expression.js","../esm/npm/@lume/kiwi@0.4.4/node_modules/@lume/kiwi/dist/strength.js","../esm/npm/@lume/kiwi@0.4.4/node_modules/@lume/kiwi/dist/constraint.js","../esm/npm/@lume/kiwi@0.4.4/node_modules/@lume/kiwi/dist/solver.js"],"sourcesContent":["export function createMap() {\n    return new IndexedMap();\n}\nclass IndexedMap {\n    index = {};\n    array = [];\n    /**\n     * Returns the number of items in the array.\n     */\n    size() {\n        return this.array.length;\n    }\n    /**\n     * Returns true if the array is empty.\n     */\n    empty() {\n        return this.array.length === 0;\n    }\n    /**\n     * Returns the item at the given array index.\n     *\n     * @param index The integer index of the desired item.\n     */\n    itemAt(index) {\n        return this.array[index];\n    }\n    /**\n     * Returns true if the key is in the array, false otherwise.\n     *\n     * @param key The key to locate in the array.\n     */\n    contains(key) {\n        return this.index[key.id()] !== undefined;\n    }\n    /**\n     * Returns the pair associated with the given key, or undefined.\n     *\n     * @param key The key to locate in the array.\n     */\n    find(key) {\n        const i = this.index[key.id()];\n        return i === undefined ? undefined : this.array[i];\n    }\n    /**\n     * Returns the pair associated with the key if it exists.\n     *\n     * If the key does not exist, a new pair will be created and\n     * inserted using the value created by the given factory.\n     *\n     * @param key The key to locate in the array.\n     * @param factory The function which creates the default value.\n     */\n    setDefault(key, factory) {\n        const i = this.index[key.id()];\n        if (i === undefined) {\n            const pair = new Pair(key, factory());\n            this.index[key.id()] = this.array.length;\n            this.array.push(pair);\n            return pair;\n        }\n        else {\n            return this.array[i];\n        }\n    }\n    /**\n     * Insert the pair into the array and return the pair.\n     *\n     * This will overwrite any existing entry in the array.\n     *\n     * @param key The key portion of the pair.\n     * @param value The value portion of the pair.\n     */\n    insert(key, value) {\n        const pair = new Pair(key, value);\n        const i = this.index[key.id()];\n        if (i === undefined) {\n            this.index[key.id()] = this.array.length;\n            this.array.push(pair);\n        }\n        else {\n            this.array[i] = pair;\n        }\n        return pair;\n    }\n    /**\n     * Removes and returns the pair for the given key, or undefined.\n     *\n     * @param key The key to remove from the map.\n     */\n    erase(key) {\n        const i = this.index[key.id()];\n        if (i === undefined) {\n            return undefined;\n        }\n        this.index[key.id()] = undefined;\n        const pair = this.array[i];\n        const last = this.array.pop();\n        if (pair !== last) {\n            this.array[i] = last;\n            this.index[last.first.id()] = i;\n        }\n        return pair;\n    }\n    /**\n     * Create a copy of this associative array.\n     */\n    copy() {\n        const copy = new IndexedMap();\n        for (let i = 0; i \u003c this.array.length; i++) {\n            const pair = this.array[i].copy();\n            copy.array[i] = pair;\n            copy.index[pair.first.id()] = i;\n        }\n        return copy;\n    }\n}\n/**\n * A class which defines a generic pair object.\n * @private\n */\n// tslint:disable: max-classes-per-file\nclass Pair {\n    first;\n    second;\n    /**\n     * Construct a new Pair object.\n     *\n     * @param first The first item of the pair.\n     * @param second The second item of the pair.\n     */\n    constructor(first, second) {\n        this.first = first;\n        this.second = second;\n    }\n    /**\n     * Create a copy of the pair.\n     */\n    copy() {\n        return new Pair(this.first, this.second);\n    }\n}\n","import { Expression } from './expression.js';\n/**\n * The primary user constraint variable.\n *\n * @class\n * @param {String} [name=\"\"] The name to associated with the variable.\n */\nexport class Variable {\n    constructor(name = '') {\n        this._name = name;\n    }\n    /**\n     * Returns the unique id number of the variable.\n     * @private\n     */\n    id() {\n        return this._id;\n    }\n    /**\n     * Returns the name of the variable.\n     *\n     * @return {String} name of the variable\n     */\n    name() {\n        return this._name;\n    }\n    /**\n     * Set the name of the variable.\n     *\n     * @param {String} name Name of the variable\n     */\n    setName(name) {\n        this._name = name;\n    }\n    /**\n     * Returns the user context object of the variable.\n     * @private\n     */\n    context() {\n        return this._context;\n    }\n    /**\n     * Set the user context object of the variable.\n     * @private\n     */\n    setContext(context) {\n        this._context = context;\n    }\n    /**\n     * Returns the value of the variable.\n     *\n     * @return {Number} Calculated value\n     */\n    value() {\n        return this._value;\n    }\n    /**\n     * Set the value of the variable.\n     * @private\n     */\n    setValue(value) {\n        this._value = value;\n    }\n    /**\n     * Creates a new Expression by adding a number, variable or expression\n     * to the variable.\n     *\n     * @param {Number|Variable|Expression} value Value to add.\n     * @return {Expression} expression\n     */\n    plus(value) {\n        return new Expression(this, value);\n    }\n    /**\n     * Creates a new Expression by substracting a number, variable or expression\n     * from the variable.\n     *\n     * @param {Number|Variable|Expression} value Value to substract.\n     * @return {Expression} expression\n     */\n    minus(value) {\n        return new Expression(this, typeof value === 'number' ? -value : [-1, value]);\n    }\n    /**\n     * Creates a new Expression by multiplying with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to multiply with.\n     * @return {Expression} expression\n     */\n    multiply(coefficient) {\n        return new Expression([coefficient, this]);\n    }\n    /**\n     * Creates a new Expression by dividing with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to divide by.\n     * @return {Expression} expression\n     */\n    divide(coefficient) {\n        return new Expression([1 / coefficient, this]);\n    }\n    /**\n     * Returns the JSON representation of the variable.\n     * @private\n     */\n    toJSON() {\n        return {\n            name: this._name,\n            value: this._value,\n        };\n    }\n    toString() {\n        return this._context + '[' + this._name + ':' + this._value + ']';\n    }\n    _name;\n    _value = 0.0;\n    _context = null;\n    _id = VarId++;\n}\n/**\n * The internal variable id counter.\n * @private\n */\nlet VarId = 0;\n","import { createMap } from './maptype.js';\nimport { Variable } from './variable.js';\n/**\n * An expression of variable terms and a constant.\n *\n * The constructor accepts an arbitrary number of parameters,\n * each of which must be one of the following types:\n *  - number\n *  - Variable\n *  - Expression\n *  - 2-tuple of [number, Variable|Expression]\n *\n * The parameters are summed. The tuples are multiplied.\n *\n * @class\n * @param {...(number|Variable|Expression|Array)} args\n */\nexport class Expression {\n    constructor() {\n        let parsed = parseArgs(arguments);\n        this._terms = parsed.terms;\n        this._constant = parsed.constant;\n    }\n    /**\n     * Returns the mapping of terms in the expression.\n     *\n     * This *must* be treated as const.\n     * @private\n     */\n    terms() {\n        return this._terms;\n    }\n    /**\n     * Returns the constant of the expression.\n     * @private\n     */\n    constant() {\n        return this._constant;\n    }\n    /**\n     * Returns the computed value of the expression.\n     *\n     * @private\n     * @return {Number} computed value of the expression\n     */\n    value() {\n        let result = this._constant;\n        for (let i = 0, n = this._terms.size(); i \u003c n; i++) {\n            let pair = this._terms.itemAt(i);\n            result += pair.first.value() * pair.second;\n        }\n        return result;\n    }\n    /**\n     * Creates a new Expression by adding a number, variable or expression\n     * to the expression.\n     *\n     * @param {Number|Variable|Expression} value Value to add.\n     * @return {Expression} expression\n     */\n    plus(value) {\n        return new Expression(this, value);\n    }\n    /**\n     * Creates a new Expression by substracting a number, variable or expression\n     * from the expression.\n     *\n     * @param {Number|Variable|Expression} value Value to substract.\n     * @return {Expression} expression\n     */\n    minus(value) {\n        return new Expression(this, typeof value === 'number' ? -value : [-1, value]);\n    }\n    /**\n     * Creates a new Expression by multiplying with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to multiply with.\n     * @return {Expression} expression\n     */\n    multiply(coefficient) {\n        return new Expression([coefficient, this]);\n    }\n    /**\n     * Creates a new Expression by dividing with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to divide by.\n     * @return {Expression} expression\n     */\n    divide(coefficient) {\n        return new Expression([1 / coefficient, this]);\n    }\n    isConstant() {\n        return this._terms.size() == 0;\n    }\n    toString() {\n        let result = this._terms.array\n            .map(function (pair) {\n            return pair.second + '*' + pair.first.toString();\n        })\n            .join(' + ');\n        if (!this.isConstant() \u0026\u0026 this._constant !== 0) {\n            result += ' + ';\n        }\n        result += this._constant;\n        return result;\n    }\n    _terms;\n    _constant;\n}\n/**\n * An internal argument parsing function.\n * @private\n */\nfunction parseArgs(args) {\n    let constant = 0.0;\n    let factory = () =\u003e 0.0;\n    let terms = createMap();\n    for (let i = 0, n = args.length; i \u003c n; ++i) {\n        let item = args[i];\n        if (typeof item === 'number') {\n            constant += item;\n        }\n        else if (item instanceof Variable) {\n            terms.setDefault(item, factory).second += 1.0;\n        }\n        else if (item instanceof Expression) {\n            constant += item.constant();\n            let terms2 = item.terms();\n            for (let j = 0, k = terms2.size(); j \u003c k; j++) {\n                let termPair = terms2.itemAt(j);\n                terms.setDefault(termPair.first, factory).second += termPair.second;\n            }\n        }\n        else if (item instanceof Array) {\n            if (item.length !== 2) {\n                throw new Error('array must have length 2');\n            }\n            let value = item[0];\n            let value2 = item[1];\n            if (typeof value !== 'number') {\n                throw new Error('array item 0 must be a number');\n            }\n            if (value2 instanceof Variable) {\n                terms.setDefault(value2, factory).second += value;\n            }\n            else if (value2 instanceof Expression) {\n                constant += value2.constant() * value;\n                let terms2 = value2.terms();\n                for (let j = 0, k = terms2.size(); j \u003c k; j++) {\n                    let termPair = terms2.itemAt(j);\n                    terms.setDefault(termPair.first, factory).second += termPair.second * value;\n                }\n            }\n            else {\n                throw new Error('array item 1 must be a variable or expression');\n            }\n        }\n        else {\n            throw new Error('invalid Expression argument: ' + item);\n        }\n    }\n    return { terms, constant };\n}\n","/**\n * @class Strength\n */\nexport class Strength {\n    /**\n     * Create a new symbolic strength.\n     *\n     * @param a strong\n     * @param b medium\n     * @param c weak\n     * @param [w] weight\n     * @return strength\n     */\n    static create(a, b, c, w = 1.0) {\n        let result = 0.0;\n        result += Math.max(0.0, Math.min(1000.0, a * w)) * 1000000.0;\n        result += Math.max(0.0, Math.min(1000.0, b * w)) * 1000.0;\n        result += Math.max(0.0, Math.min(1000.0, c * w));\n        return result;\n    }\n    /**\n     * The 'required' symbolic strength.\n     */\n    static required = Strength.create(1000.0, 1000.0, 1000.0);\n    /**\n     * The 'strong' symbolic strength.\n     */\n    static strong = Strength.create(1.0, 0.0, 0.0);\n    /**\n     * The 'medium' symbolic strength.\n     */\n    static medium = Strength.create(0.0, 1.0, 0.0);\n    /**\n     * The 'weak' symbolic strength.\n     */\n    static weak = Strength.create(0.0, 0.0, 1.0);\n    /**\n     * Clip a symbolic strength to the allowed min and max.\n     * @private\n     */\n    static clip(value) {\n        return Math.max(0.0, Math.min(Strength.required, value));\n    }\n}\n","import { Expression } from './expression.js';\nimport { Strength } from './strength.js';\n/**\n * An enum defining the linear constraint operators.\n *\n * |Value|Operator|Description|\n * |----|-----|-----|\n * |`Le`|\u003c=|Less than equal|\n * |`Ge`|\u003e=|Greater than equal|\n * |`Eq`|==|Equal|\n *\n * @enum {Number}\n */\nexport var Operator;\n(function (Operator) {\n    Operator[Operator[\"Le\"] = 0] = \"Le\";\n    Operator[Operator[\"Ge\"] = 1] = \"Ge\";\n    Operator[Operator[\"Eq\"] = 2] = \"Eq\";\n})(Operator || (Operator = {}));\n/**\n * A linear constraint equation.\n *\n * A constraint equation is composed of an expression, an operator,\n * and a strength. The RHS of the equation is implicitly zero.\n *\n * @class\n * @param {Expression} expression The constraint expression (LHS).\n * @param {Operator} operator The equation operator.\n * @param {Expression} [rhs] Right hand side of the expression.\n * @param {Number} [strength=Strength.required] The strength of the constraint.\n */\nexport class Constraint {\n    constructor(expression, operator, rhs, strength = Strength.required) {\n        this._operator = operator;\n        this._strength = Strength.clip(strength);\n        if (rhs === undefined \u0026\u0026 expression instanceof Expression) {\n            this._expression = expression;\n        }\n        else {\n            this._expression = expression.minus(rhs);\n        }\n    }\n    /**\n     * Returns the unique id number of the constraint.\n     * @private\n     */\n    id() {\n        return this._id;\n    }\n    /**\n     * Returns the expression of the constraint.\n     *\n     * @return {Expression} expression\n     */\n    expression() {\n        return this._expression;\n    }\n    /**\n     * Returns the relational operator of the constraint.\n     *\n     * @return {Operator} linear constraint operator\n     */\n    op() {\n        return this._operator;\n    }\n    /**\n     * Returns the strength of the constraint.\n     *\n     * @return {Number} strength\n     */\n    strength() {\n        return this._strength;\n    }\n    toString() {\n        return (this._expression.toString() + ' ' + ['\u003c=', '\u003e=', '='][this._operator] + ' 0 (' + this._strength.toString() + ')');\n    }\n    _expression;\n    _operator;\n    _strength;\n    _id = CnId++;\n}\n/**\n * The internal constraint id counter.\n * @private\n */\nlet CnId = 0;\n","import { Constraint, Operator } from './constraint.js';\nimport { Expression } from './expression.js';\nimport { createMap } from './maptype.js';\nimport { Strength } from './strength.js';\n/**\n * The constraint solver class.\n *\n * @class\n */\nexport class Solver {\n    /**\n     * @type {number} - The max number of solver iterations before an error\n     * is thrown, in order to prevent infinite iteration. Default: `10,000`.\n     */\n    maxIterations = 1000;\n    /**\n     * Construct a new Solver.\n     */\n    constructor() { }\n    /**\n     * Creates and add a constraint to the solver.\n     *\n     * @param {Expression|Variable} lhs Left hand side of the expression\n     * @param {Operator} operator Operator\n     * @param {Expression|Variable|Number} rhs Right hand side of the expression\n     * @param {Number} [strength=Strength.required] Strength\n     */\n    createConstraint(lhs, operator, rhs, strength = Strength.required) {\n        let cn = new Constraint(lhs, operator, rhs, strength);\n        this.addConstraint(cn);\n        return cn;\n    }\n    /**\n     * Add a constraint to the solver.\n     *\n     * @param {Constraint} constraint Constraint to add to the solver\n     */\n    addConstraint(constraint) {\n        let cnPair = this._cnMap.find(constraint);\n        if (cnPair !== undefined) {\n            throw new Error('duplicate constraint');\n        }\n        // Creating a row causes symbols to be reserved for the variables\n        // in the constraint. If this method exits with an exception,\n        // then its possible those variables will linger in the var map.\n        // Since its likely that those variables will be used in other\n        // constraints and since exceptional conditions are uncommon,\n        // i'm not too worried about aggressive cleanup of the var map.\n        let data = this._createRow(constraint);\n        let row = data.row;\n        let tag = data.tag;\n        let subject = this._chooseSubject(row, tag);\n        // If chooseSubject couldnt find a valid entering symbol, one\n        // last option is available if the entire row is composed of\n        // dummy variables. If the constant of the row is zero, then\n        // this represents redundant constraints and the new dummy\n        // marker can enter the basis. If the constant is non-zero,\n        // then it represents an unsatisfiable constraint.\n        if (subject.type() === SymbolType.Invalid \u0026\u0026 row.allDummies()) {\n            if (!nearZero(row.constant())) {\n                throw new Error('unsatisfiable constraint');\n            }\n            else {\n                subject = tag.marker;\n            }\n        }\n        // If an entering symbol still isn't found, then the row must\n        // be added using an artificial variable. If that fails, then\n        // the row represents an unsatisfiable constraint.\n        if (subject.type() === SymbolType.Invalid) {\n            if (!this._addWithArtificialVariable(row)) {\n                throw new Error('unsatisfiable constraint');\n            }\n        }\n        else {\n            row.solveFor(subject);\n            this._substitute(subject, row);\n            this._rowMap.insert(subject, row);\n        }\n        this._cnMap.insert(constraint, tag);\n        // Optimizing after each constraint is added performs less\n        // aggregate work due to a smaller average system size. It\n        // also ensures the solver remains in a consistent state.\n        this._optimize(this._objective);\n    }\n    /**\n     * Remove a constraint from the solver.\n     *\n     * @param {Constraint} constraint Constraint to remove from the solver\n     */\n    removeConstraint(constraint) {\n        let cnPair = this._cnMap.erase(constraint);\n        if (cnPair === undefined) {\n            throw new Error('unknown constraint');\n        }\n        // Remove the error effects from the objective function\n        // *before* pivoting, or substitutions into the objective\n        // will lead to incorrect solver results.\n        this._removeConstraintEffects(constraint, cnPair.second);\n        // If the marker is basic, simply drop the row. Otherwise,\n        // pivot the marker into the basis and then drop the row.\n        let marker = cnPair.second.marker;\n        let rowPair = this._rowMap.erase(marker);\n        if (rowPair === undefined) {\n            let leaving = this._getMarkerLeavingSymbol(marker);\n            if (leaving.type() === SymbolType.Invalid) {\n                throw new Error('failed to find leaving row');\n            }\n            rowPair = this._rowMap.erase(leaving);\n            rowPair.second.solveForEx(leaving, marker);\n            this._substitute(marker, rowPair.second);\n        }\n        // Optimizing after each constraint is removed ensures that the\n        // solver remains consistent. It makes the solver api easier to\n        // use at a small tradeoff for speed.\n        this._optimize(this._objective);\n    }\n    /**\n     * Test whether the solver contains the constraint.\n     *\n     * @param {Constraint} constraint Constraint to test for\n     * @return {Bool} true or false\n     */\n    hasConstraint(constraint) {\n        return this._cnMap.contains(constraint);\n    }\n    /**\n     * Get an array of the current constraints.\n     *\n     * @return {Constraint[]}\n     */\n    getConstraints() {\n        return this._cnMap.array.map(({ first }) =\u003e first);\n    }\n    /**\n     * Add an edit variable to the solver.\n     *\n     * @param {Variable} variable Edit variable to add to the solver\n     * @param {Number} strength Strength, should be less than `Strength.required`\n     */\n    addEditVariable(variable, strength) {\n        let editPair = this._editMap.find(variable);\n        if (editPair !== undefined) {\n            throw new Error('duplicate edit variable');\n        }\n        strength = Strength.clip(strength);\n        if (strength === Strength.required) {\n            throw new Error('bad required strength');\n        }\n        let expr = new Expression(variable);\n        let cn = new Constraint(expr, Operator.Eq, undefined, strength);\n        this.addConstraint(cn);\n        let tag = this._cnMap.find(cn).second;\n        let info = { tag, constraint: cn, constant: 0.0 };\n        this._editMap.insert(variable, info);\n    }\n    /**\n     * Remove an edit variable from the solver.\n     *\n     * @param {Variable} variable Edit variable to remove from the solver\n     */\n    removeEditVariable(variable) {\n        let editPair = this._editMap.erase(variable);\n        if (editPair === undefined) {\n            throw new Error('unknown edit variable');\n        }\n        this.removeConstraint(editPair.second.constraint);\n    }\n    /**\n     * Test whether the solver contains the edit variable.\n     *\n     * @param {Variable} variable Edit variable to test for\n     * @return {Bool} true or false\n     */\n    hasEditVariable(variable) {\n        return this._editMap.contains(variable);\n    }\n    /**\n     * Suggest the value of an edit variable.\n     *\n     * @param {Variable} variable Edit variable to suggest a value for\n     * @param {Number} value Suggested value\n     */\n    suggestValue(variable, value) {\n        let editPair = this._editMap.find(variable);\n        if (editPair === undefined) {\n            throw new Error('unknown edit variable');\n        }\n        let rows = this._rowMap;\n        let info = editPair.second;\n        let delta = value - info.constant;\n        info.constant = value;\n        // Check first if the positive error variable is basic.\n        let marker = info.tag.marker;\n        let rowPair = rows.find(marker);\n        if (rowPair !== undefined) {\n            if (rowPair.second.add(-delta) \u003c 0.0) {\n                this._infeasibleRows.push(marker);\n            }\n            this._dualOptimize();\n            return;\n        }\n        // Check next if the negative error variable is basic.\n        let other = info.tag.other;\n        rowPair = rows.find(other);\n        if (rowPair !== undefined) {\n            if (rowPair.second.add(delta) \u003c 0.0) {\n                this._infeasibleRows.push(other);\n            }\n            this._dualOptimize();\n            return;\n        }\n        // Otherwise update each row where the error variables exist.\n        for (let i = 0, n = rows.size(); i \u003c n; ++i) {\n            let rowPair = rows.itemAt(i);\n            let row = rowPair.second;\n            let coeff = row.coefficientFor(marker);\n            if (coeff !== 0.0 \u0026\u0026 row.add(delta * coeff) \u003c 0.0 \u0026\u0026 rowPair.first.type() !== SymbolType.External) {\n                this._infeasibleRows.push(rowPair.first);\n            }\n        }\n        this._dualOptimize();\n    }\n    /**\n     * Update the values of the variables.\n     */\n    updateVariables() {\n        let vars = this._varMap;\n        let rows = this._rowMap;\n        for (let i = 0, n = vars.size(); i \u003c n; ++i) {\n            let pair = vars.itemAt(i);\n            let rowPair = rows.find(pair.second);\n            if (rowPair !== undefined) {\n                pair.first.setValue(rowPair.second.constant());\n            }\n            else {\n                pair.first.setValue(0.0);\n            }\n        }\n    }\n    /**\n     * Get the symbol for the given variable.\n     *\n     * If a symbol does not exist for the variable, one will be created.\n     * @private\n     */\n    _getVarSymbol(variable) {\n        let factory = () =\u003e this._makeSymbol(SymbolType.External);\n        return this._varMap.setDefault(variable, factory).second;\n    }\n    /**\n     * Create a new Row object for the given constraint.\n     *\n     * The terms in the constraint will be converted to cells in the row.\n     * Any term in the constraint with a coefficient of zero is ignored.\n     * This method uses the `_getVarSymbol` method to get the symbol for\n     * the variables added to the row. If the symbol for a given cell\n     * variable is basic, the cell variable will be substituted with the\n     * basic row.\n     *\n     * The necessary slack and error variables will be added to the row.\n     * If the constant for the row is negative, the sign for the row\n     * will be inverted so the constant becomes positive.\n     *\n     * Returns the created Row and the tag for tracking the constraint.\n     * @private\n     */\n    _createRow(constraint) {\n        let expr = constraint.expression();\n        let row = new Row(expr.constant());\n        // Substitute the current basic variables into the row.\n        let terms = expr.terms();\n        for (let i = 0, n = terms.size(); i \u003c n; ++i) {\n            let termPair = terms.itemAt(i);\n            if (!nearZero(termPair.second)) {\n                let symbol = this._getVarSymbol(termPair.first);\n                let basicPair = this._rowMap.find(symbol);\n                if (basicPair !== undefined) {\n                    row.insertRow(basicPair.second, termPair.second);\n                }\n                else {\n                    row.insertSymbol(symbol, termPair.second);\n                }\n            }\n        }\n        // Add the necessary slack, error, and dummy variables.\n        let objective = this._objective;\n        let strength = constraint.strength();\n        let tag = { marker: INVALID_SYMBOL, other: INVALID_SYMBOL };\n        switch (constraint.op()) {\n            case Operator.Le:\n            case Operator.Ge: {\n                let coeff = constraint.op() === Operator.Le ? 1.0 : -1.0;\n                let slack = this._makeSymbol(SymbolType.Slack);\n                tag.marker = slack;\n                row.insertSymbol(slack, coeff);\n                if (strength \u003c Strength.required) {\n                    let error = this._makeSymbol(SymbolType.Error);\n                    tag.other = error;\n                    row.insertSymbol(error, -coeff);\n                    objective.insertSymbol(error, strength);\n                }\n                break;\n            }\n            case Operator.Eq: {\n                if (strength \u003c Strength.required) {\n                    let errplus = this._makeSymbol(SymbolType.Error);\n                    let errminus = this._makeSymbol(SymbolType.Error);\n                    tag.marker = errplus;\n                    tag.other = errminus;\n                    row.insertSymbol(errplus, -1.0); // v = eplus - eminus\n                    row.insertSymbol(errminus, 1.0); // v - eplus + eminus = 0\n                    objective.insertSymbol(errplus, strength);\n                    objective.insertSymbol(errminus, strength);\n                }\n                else {\n                    let dummy = this._makeSymbol(SymbolType.Dummy);\n                    tag.marker = dummy;\n                    row.insertSymbol(dummy);\n                }\n                break;\n            }\n        }\n        // Ensure the row has a positive constant.\n        if (row.constant() \u003c 0.0) {\n            row.reverseSign();\n        }\n        return { row, tag };\n    }\n    /**\n     * Choose the subject for solving for the row.\n     *\n     * This method will choose the best subject for using as the solve\n     * target for the row. An invalid symbol will be returned if there\n     * is no valid target.\n     *\n     * The symbols are chosen according to the following precedence:\n     *\n     * 1) The first symbol representing an external variable.\n     * 2) A negative slack or error tag variable.\n     *\n     * If a subject cannot be found, an invalid symbol will be returned.\n     *\n     * @private\n     */\n    _chooseSubject(row, tag) {\n        let cells = row.cells();\n        for (let i = 0, n = cells.size(); i \u003c n; ++i) {\n            let pair = cells.itemAt(i);\n            if (pair.first.type() === SymbolType.External) {\n                return pair.first;\n            }\n        }\n        let type = tag.marker.type();\n        if (type === SymbolType.Slack || type === SymbolType.Error) {\n            if (row.coefficientFor(tag.marker) \u003c 0.0) {\n                return tag.marker;\n            }\n        }\n        type = tag.other.type();\n        if (type === SymbolType.Slack || type === SymbolType.Error) {\n            if (row.coefficientFor(tag.other) \u003c 0.0) {\n                return tag.other;\n            }\n        }\n        return INVALID_SYMBOL;\n    }\n    /**\n     * Add the row to the tableau using an artificial variable.\n     *\n     * This will return false if the constraint cannot be satisfied.\n     *\n     * @private\n     */\n    _addWithArtificialVariable(row) {\n        // Create and add the artificial variable to the tableau.\n        let art = this._makeSymbol(SymbolType.Slack);\n        this._rowMap.insert(art, row.copy());\n        this._artificial = row.copy();\n        // Optimize the artificial objective. This is successful\n        // only if the artificial objective is optimized to zero.\n        this._optimize(this._artificial);\n        let success = nearZero(this._artificial.constant());\n        this._artificial = null;\n        // If the artificial variable is basic, pivot the row so that\n        // it becomes non-basic. If the row is constant, exit early.\n        let pair = this._rowMap.erase(art);\n        if (pair !== undefined) {\n            let basicRow = pair.second;\n            if (basicRow.isConstant()) {\n                return success;\n            }\n            let entering = this._anyPivotableSymbol(basicRow);\n            if (entering.type() === SymbolType.Invalid) {\n                return false; // unsatisfiable (will this ever happen?)\n            }\n            basicRow.solveForEx(art, entering);\n            this._substitute(entering, basicRow);\n            this._rowMap.insert(entering, basicRow);\n        }\n        // Remove the artificial variable from the tableau.\n        let rows = this._rowMap;\n        for (let i = 0, n = rows.size(); i \u003c n; ++i) {\n            rows.itemAt(i).second.removeSymbol(art);\n        }\n        this._objective.removeSymbol(art);\n        return success;\n    }\n    /**\n     * Substitute the parametric symbol with the given row.\n     *\n     * This method will substitute all instances of the parametric symbol\n     * in the tableau and the objective function with the given row.\n     *\n     * @private\n     */\n    _substitute(symbol, row) {\n        let rows = this._rowMap;\n        for (let i = 0, n = rows.size(); i \u003c n; ++i) {\n            let pair = rows.itemAt(i);\n            pair.second.substitute(symbol, row);\n            if (pair.second.constant() \u003c 0.0 \u0026\u0026 pair.first.type() !== SymbolType.External) {\n                this._infeasibleRows.push(pair.first);\n            }\n        }\n        this._objective.substitute(symbol, row);\n        if (this._artificial) {\n            this._artificial.substitute(symbol, row);\n        }\n    }\n    /**\n     * Optimize the system for the given objective function.\n     *\n     * This method performs iterations of Phase 2 of the simplex method\n     * until the objective function reaches a minimum.\n     *\n     * @private\n     */\n    _optimize(objective) {\n        let iterations = 0;\n        while (iterations \u003c this.maxIterations) {\n            let entering = this._getEnteringSymbol(objective);\n            if (entering.type() === SymbolType.Invalid) {\n                return;\n            }\n            let leaving = this._getLeavingSymbol(entering);\n            if (leaving.type() === SymbolType.Invalid) {\n                throw new Error('the objective is unbounded');\n            }\n            // pivot the entering symbol into the basis\n            let row = this._rowMap.erase(leaving).second;\n            row.solveForEx(leaving, entering);\n            this._substitute(entering, row);\n            this._rowMap.insert(entering, row);\n            iterations++;\n        }\n        throw new Error('solver iterations exceeded');\n    }\n    /**\n     * Optimize the system using the dual of the simplex method.\n     *\n     * The current state of the system should be such that the objective\n     * function is optimal, but not feasible. This method will perform\n     * an iteration of the dual simplex method to make the solution both\n     * optimal and feasible.\n     *\n     * @private\n     */\n    _dualOptimize() {\n        let rows = this._rowMap;\n        let infeasible = this._infeasibleRows;\n        while (infeasible.length !== 0) {\n            let leaving = infeasible.pop();\n            let pair = rows.find(leaving);\n            if (pair !== undefined \u0026\u0026 pair.second.constant() \u003c 0.0) {\n                let entering = this._getDualEnteringSymbol(pair.second);\n                if (entering.type() === SymbolType.Invalid) {\n                    throw new Error('dual optimize failed');\n                }\n                // pivot the entering symbol into the basis\n                let row = pair.second;\n                rows.erase(leaving);\n                row.solveForEx(leaving, entering);\n                this._substitute(entering, row);\n                rows.insert(entering, row);\n            }\n        }\n    }\n    /**\n     * Compute the entering variable for a pivot operation.\n     *\n     * This method will return first symbol in the objective function which\n     * is non-dummy and has a coefficient less than zero. If no symbol meets\n     * the criteria, it means the objective function is at a minimum, and an\n     * invalid symbol is returned.\n     *\n     * @private\n     */\n    _getEnteringSymbol(objective) {\n        let cells = objective.cells();\n        for (let i = 0, n = cells.size(); i \u003c n; ++i) {\n            let pair = cells.itemAt(i);\n            let symbol = pair.first;\n            if (pair.second \u003c 0.0 \u0026\u0026 symbol.type() !== SymbolType.Dummy) {\n                return symbol;\n            }\n        }\n        return INVALID_SYMBOL;\n    }\n    /**\n     * Compute the entering symbol for the dual optimize operation.\n     *\n     * This method will return the symbol in the row which has a positive\n     * coefficient and yields the minimum ratio for its respective symbol\n     * in the objective function. The provided row *must* be infeasible.\n     * If no symbol is found which meats the criteria, an invalid symbol\n     * is returned.\n     *\n     * @private\n     */\n    _getDualEnteringSymbol(row) {\n        let ratio = Number.MAX_VALUE;\n        let entering = INVALID_SYMBOL;\n        let cells = row.cells();\n        for (let i = 0, n = cells.size(); i \u003c n; ++i) {\n            let pair = cells.itemAt(i);\n            let symbol = pair.first;\n            let c = pair.second;\n            if (c \u003e 0.0 \u0026\u0026 symbol.type() !== SymbolType.Dummy) {\n                let coeff = this._objective.coefficientFor(symbol);\n                let r = coeff / c;\n                if (r \u003c ratio) {\n                    ratio = r;\n                    entering = symbol;\n                }\n            }\n        }\n        return entering;\n    }\n    /**\n     * Compute the symbol for pivot exit row.\n     *\n     * This method will return the symbol for the exit row in the row\n     * map. If no appropriate exit symbol is found, an invalid symbol\n     * will be returned. This indicates that the objective function is\n     * unbounded.\n     *\n     * @private\n     */\n    _getLeavingSymbol(entering) {\n        let ratio = Number.MAX_VALUE;\n        let found = INVALID_SYMBOL;\n        let rows = this._rowMap;\n        for (let i = 0, n = rows.size(); i \u003c n; ++i) {\n            let pair = rows.itemAt(i);\n            let symbol = pair.first;\n            if (symbol.type() !== SymbolType.External) {\n                let row = pair.second;\n                let temp = row.coefficientFor(entering);\n                if (temp \u003c 0.0) {\n                    let temp_ratio = -row.constant() / temp;\n                    if (temp_ratio \u003c ratio) {\n                        ratio = temp_ratio;\n                        found = symbol;\n                    }\n                }\n            }\n        }\n        return found;\n    }\n    /**\n     * Compute the leaving symbol for a marker variable.\n     *\n     * This method will return a symbol corresponding to a basic row\n     * which holds the given marker variable. The row will be chosen\n     * according to the following precedence:\n     *\n     * 1) The row with a restricted basic varible and a negative coefficient\n     *    for the marker with the smallest ratio of -constant / coefficient.\n     *\n     * 2) The row with a restricted basic variable and the smallest ratio\n     *    of constant / coefficient.\n     *\n     * 3) The last unrestricted row which contains the marker.\n     *\n     * If the marker does not exist in any row, an invalid symbol will be\n     * returned. This indicates an internal solver error since the marker\n     * *should* exist somewhere in the tableau.\n     *\n     * @private\n     */\n    _getMarkerLeavingSymbol(marker) {\n        let dmax = Number.MAX_VALUE;\n        let r1 = dmax;\n        let r2 = dmax;\n        let invalid = INVALID_SYMBOL;\n        let first = invalid;\n        let second = invalid;\n        let third = invalid;\n        let rows = this._rowMap;\n        for (let i = 0, n = rows.size(); i \u003c n; ++i) {\n            let pair = rows.itemAt(i);\n            let row = pair.second;\n            let c = row.coefficientFor(marker);\n            if (c === 0.0) {\n                continue;\n            }\n            let symbol = pair.first;\n            if (symbol.type() === SymbolType.External) {\n                third = symbol;\n            }\n            else if (c \u003c 0.0) {\n                let r = -row.constant() / c;\n                if (r \u003c r1) {\n                    r1 = r;\n                    first = symbol;\n                }\n            }\n            else {\n                let r = row.constant() / c;\n                if (r \u003c r2) {\n                    r2 = r;\n                    second = symbol;\n                }\n            }\n        }\n        if (first !== invalid) {\n            return first;\n        }\n        if (second !== invalid) {\n            return second;\n        }\n        return third;\n    }\n    /**\n     * Remove the effects of a constraint on the objective function.\n     *\n     * @private\n     */\n    _removeConstraintEffects(cn, tag) {\n        if (tag.marker.type() === SymbolType.Error) {\n            this._removeMarkerEffects(tag.marker, cn.strength());\n        }\n        if (tag.other.type() === SymbolType.Error) {\n            this._removeMarkerEffects(tag.other, cn.strength());\n        }\n    }\n    /**\n     * Remove the effects of an error marker on the objective function.\n     *\n     * @private\n     */\n    _removeMarkerEffects(marker, strength) {\n        let pair = this._rowMap.find(marker);\n        if (pair !== undefined) {\n            this._objective.insertRow(pair.second, -strength);\n        }\n        else {\n            this._objective.insertSymbol(marker, -strength);\n        }\n    }\n    /**\n     * Get the first Slack or Error symbol in the row.\n     *\n     * If no such symbol is present, an invalid symbol will be returned.\n     *\n     * @private\n     */\n    _anyPivotableSymbol(row) {\n        let cells = row.cells();\n        for (let i = 0, n = cells.size(); i \u003c n; ++i) {\n            let pair = cells.itemAt(i);\n            let type = pair.first.type();\n            if (type === SymbolType.Slack || type === SymbolType.Error) {\n                return pair.first;\n            }\n        }\n        return INVALID_SYMBOL;\n    }\n    /**\n     * Returns a new Symbol of the given type.\n     *\n     * @private\n     */\n    _makeSymbol(type) {\n        return new Symbol(type, this._idTick++);\n    }\n    _cnMap = createCnMap();\n    _rowMap = createRowMap();\n    _varMap = createVarMap();\n    _editMap = createEditMap();\n    _infeasibleRows = [];\n    _objective = new Row();\n    _artificial = null;\n    _idTick = 0;\n}\n/**\n * Test whether a value is approximately zero.\n * @private\n */\nfunction nearZero(value) {\n    let eps = 1.0e-8;\n    return value \u003c 0.0 ? -value \u003c eps : value \u003c eps;\n}\n/**\n * An internal function for creating a constraint map.\n * @private\n */\nfunction createCnMap() {\n    return createMap();\n}\n/**\n * An internal function for creating a row map.\n * @private\n */\nfunction createRowMap() {\n    return createMap();\n}\n/**\n * An internal function for creating a variable map.\n * @private\n */\nfunction createVarMap() {\n    return createMap();\n}\n/**\n * An internal function for creating an edit map.\n * @private\n */\nfunction createEditMap() {\n    return createMap();\n}\n/**\n * An enum defining the available symbol types.\n * @private\n */\nvar SymbolType;\n(function (SymbolType) {\n    SymbolType[SymbolType[\"Invalid\"] = 0] = \"Invalid\";\n    SymbolType[SymbolType[\"External\"] = 1] = \"External\";\n    SymbolType[SymbolType[\"Slack\"] = 2] = \"Slack\";\n    SymbolType[SymbolType[\"Error\"] = 3] = \"Error\";\n    SymbolType[SymbolType[\"Dummy\"] = 4] = \"Dummy\";\n})(SymbolType || (SymbolType = {}));\n/**\n * An internal class representing a symbol in the solver.\n * @private\n */\nclass Symbol {\n    /**\n     * Construct a new Symbol\n     *\n     * @param [type] The type of the symbol.\n     * @param [id] The unique id number of the symbol.\n     */\n    constructor(type, id) {\n        this._id = id;\n        this._type = type;\n    }\n    /**\n     * Returns the unique id number of the symbol.\n     */\n    id() {\n        return this._id;\n    }\n    /**\n     * Returns the type of the symbol.\n     */\n    type() {\n        return this._type;\n    }\n    _id;\n    _type;\n}\n/**\n * A static invalid symbol\n * @private\n */\nlet INVALID_SYMBOL = new Symbol(SymbolType.Invalid, -1);\n/**\n * An internal row class used by the solver.\n * @private\n */\nclass Row {\n    /**\n     * Construct a new Row.\n     */\n    constructor(constant = 0.0) {\n        this._constant = constant;\n    }\n    /**\n     * Returns the mapping of symbols to coefficients.\n     */\n    cells() {\n        return this._cellMap;\n    }\n    /**\n     * Returns the constant for the row.\n     */\n    constant() {\n        return this._constant;\n    }\n    /**\n     * Returns true if the row is a constant value.\n     */\n    isConstant() {\n        return this._cellMap.empty();\n    }\n    /**\n     * Returns true if the Row has all dummy symbols.\n     */\n    allDummies() {\n        let cells = this._cellMap;\n        for (let i = 0, n = cells.size(); i \u003c n; ++i) {\n            let pair = cells.itemAt(i);\n            if (pair.first.type() !== SymbolType.Dummy) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Create a copy of the row.\n     */\n    copy() {\n        let theCopy = new Row(this._constant);\n        theCopy._cellMap = this._cellMap.copy();\n        return theCopy;\n    }\n    /**\n     * Add a constant value to the row constant.\n     *\n     * Returns the new value of the constant.\n     */\n    add(value) {\n        return (this._constant += value);\n    }\n    /**\n     * Insert the symbol into the row with the given coefficient.\n     *\n     * If the symbol already exists in the row, the coefficient\n     * will be added to the existing coefficient. If the resulting\n     * coefficient is zero, the symbol will be removed from the row.\n     */\n    insertSymbol(symbol, coefficient = 1.0) {\n        let pair = this._cellMap.setDefault(symbol, () =\u003e 0.0);\n        if (nearZero((pair.second += coefficient))) {\n            this._cellMap.erase(symbol);\n        }\n    }\n    /**\n     * Insert a row into this row with a given coefficient.\n     *\n     * The constant and the cells of the other row will be\n     * multiplied by the coefficient and added to this row. Any\n     * cell with a resulting coefficient of zero will be removed\n     * from the row.\n     */\n    insertRow(other, coefficient = 1.0) {\n        this._constant += other._constant * coefficient;\n        let cells = other._cellMap;\n        for (let i = 0, n = cells.size(); i \u003c n; ++i) {\n            let pair = cells.itemAt(i);\n            this.insertSymbol(pair.first, pair.second * coefficient);\n        }\n    }\n    /**\n     * Remove a symbol from the row.\n     */\n    removeSymbol(symbol) {\n        this._cellMap.erase(symbol);\n    }\n    /**\n     * Reverse the sign of the constant and cells in the row.\n     */\n    reverseSign() {\n        this._constant = -this._constant;\n        let cells = this._cellMap;\n        for (let i = 0, n = cells.size(); i \u003c n; ++i) {\n            let pair = cells.itemAt(i);\n            pair.second = -pair.second;\n        }\n    }\n    /**\n     * Solve the row for the given symbol.\n     *\n     * This method assumes the row is of the form\n     * a * x + b * y + c = 0 and (assuming solve for x) will modify\n     * the row to represent the right hand side of\n     * x = -b/a * y - c / a. The target symbol will be removed from\n     * the row, and the constant and other cells will be multiplied\n     * by the negative inverse of the target coefficient.\n     *\n     * The given symbol *must* exist in the row.\n     */\n    solveFor(symbol) {\n        let cells = this._cellMap;\n        let pair = cells.erase(symbol);\n        let coeff = -1.0 / pair.second;\n        this._constant *= coeff;\n        for (let i = 0, n = cells.size(); i \u003c n; ++i) {\n            cells.itemAt(i).second *= coeff;\n        }\n    }\n    /**\n     * Solve the row for the given symbols.\n     *\n     * This method assumes the row is of the form\n     * x = b * y + c and will solve the row such that\n     * y = x / b - c / b. The rhs symbol will be removed from the\n     * row, the lhs added, and the result divided by the negative\n     * inverse of the rhs coefficient.\n     *\n     * The lhs symbol *must not* exist in the row, and the rhs\n     * symbol must* exist in the row.\n     */\n    solveForEx(lhs, rhs) {\n        this.insertSymbol(lhs, -1.0);\n        this.solveFor(rhs);\n    }\n    /**\n     * Returns the coefficient for the given symbol.\n     */\n    coefficientFor(symbol) {\n        let pair = this._cellMap.find(symbol);\n        return pair !== undefined ? pair.second : 0.0;\n    }\n    /**\n     * Substitute a symbol with the data from another row.\n     *\n     * Given a row of the form a * x + b and a substitution of the\n     * form x = 3 * y + c the row will be updated to reflect the\n     * expression 3 * a * y + a * c + b.\n     *\n     * If the symbol does not exist in the row, this is a no-op.\n     */\n    substitute(symbol, row) {\n        let pair = this._cellMap.erase(symbol);\n        if (pair !== undefined) {\n            this.insertRow(row, pair.second);\n        }\n    }\n    _cellMap = createMap();\n    _constant;\n}\n"],"version":3}